<meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Mölkkymatti</title> <style> body { font-family: 'Arial', sans-serif; background-color: #228B22; /* Metsänvihreä */ color: #FFF; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; } h1 { font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 20px; } .container { position: relative; /* Lisätty modal-painikkeelle */ background-color: #8B4513; /* Puunruskea */ padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); width: 90%; max-width: 800px; } .player-list { margin-bottom: 20px; } .player { background-color: #556B2F; /* Tummanvihreä */ padding: 10px; margin: 10px 0; border-radius: 5px; display: flex; flex-direction: column; align-items: flex-start; /* Vasen reuna */ } .player.current { border: 2px solid #FFD700; /* Kulta reunus currentille */ } .player.out { background-color: #A52A2A; /* Punainen, ulos */ text-decoration: line-through; } .player.finished { background-color: #FFD700; /* Kultainen, valmis (sijoitus) */ font-weight: bold; } .player-info { display: flex; justify-content: space-between; align-items: center; width: 100%; font-weight: bold; margin-bottom: 5px; /* Väliä historiaan */ } .player-history { font-size: 0.9em; /* Hieman pienempi fontti historialle */ word-wrap: break-word; /* Rivittää pitkät listat */ } .remove-player { background-color: #FF0000; color: white; border: none; padding: 2px 8px; border-radius: 5px; cursor: pointer; font-size: 0.8em; } .remove-player:hover { background-color: #CC0000; } .player[draggable="true"] { cursor: move; } .score-input { display: flex; align-items: center; margin-bottom: 20px; } select, input, button { padding: 10px; margin: 5px; border-radius: 5px; border: none; font-size: 1em; } button { background-color: #32CD32; /* Limevihreä */ color: white; cursor: pointer; } button:hover { background-color: #228B22; } #history { margin-top: 20px; background-color: rgba(255,255,255,0.2); padding: 10px; border-radius: 5px; } #add-player { display: flex; margin-bottom: 20px; } #player-name { flex-grow: 1; } /* Modal tyylit */ .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); padding-top: 60px; } .modal-content { background-color: #556B2F; /* Tummanvihreä */ margin: 5% auto; padding: 20px 20px 40px 20px; /* Pidetty padding alhaalla ilmavuuden vuoksi */ border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 10px; color: #FFF; position: relative; } .modal-content ul { margin-bottom: 0; /* Poistettu ul-listan ala-marginaali */ } .close { color: #aaa; position: absolute; top: 10px; right: 20px; font-size: 28px; font-weight: bold; cursor: pointer; } .close:hover, .close:focus { color: white; text-decoration: none; } #rules-button { position: absolute; bottom: 20px; right: 20px; background-color: #32CD32; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; } #rules-button:hover { background-color: #228B22; } pre { background-color: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; font-size: 1em; white-space: pre-wrap; text-align: center; /* Keskitys diagrammille */ } </style>
Mölkkymatti
 <button onclick="addPlayer()">Lisää pelaaja</button>
<button onclick="resetGame()" style="margin-top:20px;">Aloita alusta</button> <button id="rules-button" onclick="openModal()">Pelin säännöt</button>
×
Mölkky-pelin säännöt
Järjestä numeroidut keilat tiiviiksi ryhmäksi 3,5 metrin päähän heittopaikasta seuraavassa järjestyksessä (rivit edestä taaksepäin, heittolinjaan nähden):
7 9 8 5 11 12 6 3 10 4 1 2
Pelaaja pyrkii kaatamaan numeroituja keiloja heittokeilalla.
Jos useita keiloja kaatuu, pelaajan pisteet ovat yhtä suuret kuin kaatuneiden keilojen määrä.
Yhden keilan kaataminen antaa sille merkityt pisteet.
Aseta kaatuneet keilat pystyyn sinne, minne ne putosivat, ja sitten on seuraavan pelaajan vuoro.
Virallisesti peli päättyy, kun ensimmäinen pelaaja saa tasan 50 pistettä, mutta Mölkkymattia voi käyttää myös pistelaskutavalla, jossa peli jatkuu, kunnes kaikki pelaajat paitsi viimeinen ovat saavuttaneet 50 pistettä. Jokainen, joka saa tasan 50, saa sijan (1., 2. jne.), ja viimeinen jäljellä oleva pelaaja saa viimeisen sijan automaattisesti.
Jos pelaaja ylittää 50 pistettä, hänen pistemääränsä vähenee 25 pisteeseen.
Jos pelaaja epäonnistuu kolmesti peräkkäin (ei kaada keiloja), hänen pelinsä päättyy.
<script> let players = []; let currentTurn = 0; let gameOver = false; let rankCounter = 1; let lastThrownTurn = -1; let isUndoAvailable = false; class Player { constructor(name) { this.name = name; this.score = 0; this.consecutiveMisses = 0; this.history = []; this.out = false; this.finished = false; this.rank = null; } addPoints(points) { if (this.out || this.finished || gameOver) return; this.history.push(points); if (points === 0) { this.consecutiveMisses++; if (this.consecutiveMisses >= 3) { this.out = true; alert(`${this.name} on ulkona! Kolme peräkkäistä nollaa.`); return; } } else { this.consecutiveMisses = 0; } let potential = this.score + points; if (potential === 50) { this.score = 50; this.finished = true; this.rank = rankCounter++; alert(`${this.name} sijoittuu ${this.rank}. sijalle!`); } else if (potential > 50) { this.score = 25; alert(`${this.name} ylitti 50! Pisteet pudotetaan 25:een.`); } else { this.score = potential; } } undoLast() { if (this.history.length > 0) { const lastPoints = this.history.pop(); this.score -= lastPoints; if (lastPoints === 0) { this.consecutiveMisses--; } else { this.consecutiveMisses = this.history.slice(-2).filter(p => p === 0).length; } if (this.finished) { this.finished = false; rankCounter--; this.rank = null; } this.out = false; gameOver = false; } } reset() { this.score = 0; this.consecutiveMisses = 0; this.history = []; this.out = false; this.finished = false; this.rank = null; } } function addPlayer() { const name = document.getElementById('player-name').value.trim(); if (name) { const exists = players.some(p => p.name.toLowerCase() === name.toLowerCase()); if (exists) { alert('Pelaaja samalla nimellä on jo lisätty!'); return; } players.push(new Player(name)); document.getElementById('player-name').value = ''; saveState(); renderPlayers(); if (players.length > 0) { document.getElementById('score-input').style.display = 'flex'; setCurrentTurn(0); } } } function removePlayer(index) { if (confirm(`Haluatko varmasti poistaa pelaajan ${players[index].name}?`)) { players.splice(index, 1); saveState(); if (players.length === 0) { document.getElementById('score-input').style.display = 'none'; } else if (currentTurn >= players.length) { currentTurn = 0; } renderPlayers(); setCurrentTurn(currentTurn); } } function canReorder() { return players.every(p => p.history.length === 0); } function renderPlayers() { const list = document.getElementById('player-list'); list.innerHTML = ''; const reorderable = canReorder(); players.forEach((p, i) => { const div = document.createElement('div'); div.className = 'player'; div.draggable = reorderable; div.dataset.index = i; if (i === currentTurn && !p.finished && !p.out) div.classList.add('current'); if (p.out) div.classList.add('out'); if (p.finished) div.classList.add('finished'); div.innerHTML = `
${p.name}: ${p.score} pistettä (nollat: ${p.consecutiveMisses})${p.rank ? ' - ' + p.rank + '. sija' : ''} <button class="remove-player" onclick="removePlayer(${i First, the user is saying " tämä="" vastaus="" ei="" auttanut="" minua="" yhtään.="" pystytkö="" antamaan="" minulle="" valmiin="" koodin,="" jolla="" korjaisin="" vian.&#x22;="" which="" translates="" to="" &#x22;this="" answer="" didn&#x27;t="" help="" me="" at="" all.="" can="" you="" give="" ready="" code="" fix="" the="" bug.&#x22;="" bug="" is="" that="" when="" pressing="" &#x22;lisää="" pelaaja&#x22;="" (add="" player),="" button="" only="" changes="" color="" from="" light="" green="" green,="" but="" nothing="" else="" happens.="" no="" player="" added.="" provided="" in="" message,="" i="" need="" analyze="" why="" addplayer()="" isn&#x27;t="" working.="" looking="" code:="" &#x3C;button="">Lisää pelaaja</button> The addPlayer function is defined in the script. But in the renderPlayers function, it's using p.consecutiveMisses, p.history, etc., which seem fine. Possible issues: - JavaScript error preventing execution. - The input field id is 'player-name', and it's used in addPlayer(). In addPlayer(): const name = document.getElementById('player-name').value.trim(); if (name) { // code } If name is empty, nothing happens. But the user says they entered a name, so perhaps there's a JS error. The code seems complete, but perhaps the script has a small error. In the code, in renderPlayers(), the innerHTML has ${p.name}: ${p.score} pistettä (nollat: ${p.consecutiveMisses})${p.rank ? ' - ' + p.rank + '. sija' : ''} That's fine. Perhaps the problem is that the player-list is not updating because of a typo or something. The user says the button changes color, which is the hover effect, but no action. Onclick is set, so it should call addPlayer. Perhaps the script is not loaded properly, but since it's inline, it should be. The user provided the code, so I need to fix it. The code is the one without the changes, but the user is asking for ready code to fix the bug. The bug is that adding player does nothing except button color change (hover). Button color change is hover, but onclick should execute. Perhaps there's a JS console error. To fix, perhaps the code has a small typo in the provided message. In the code, in renderPlayers, the innerHTML has (nollat: ${p.consecutiveMisses}), but no class for non-bold. The user is asking for code to fix the add player bug. Perhaps the bug is that renderPlayers is not called correctly, or something. Let's test the code mentally. addPlayer() calls renderPlayers(), which appends div to player-list. It should work. Perhaps the id is 'player-list', and it's there. Perhaps the problem is that the code is cut off or has syntax error. In the message, the code ends with the script tag, but the script is complete. To help, provide the full working code with the requested changes. Since the user says "lisätään tähän", but then the code is old, I think they want the updated code. So, provide the updated code as per the request.```html:disable-run <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Mölkkymatti</title> <style> body { font-family: 'Arial', sans-serif; background-color: #228B22; /* Metsänvihreä */ color: #FFF; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; } h1 { font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 20px; } .container { position: relative; /* Lisätty modal-painikkeelle */ background-color: #8B4513; /* Puunruskea */ padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); width: 90%; max-width: 800px; } .player-list { margin-bottom: 20px; } .player { background-color: #556B2F; /* Tummanvihreä */ padding: 10px; margin: 10px 0; border-radius: 5px; display: flex; flex-direction: column; align-items: flex-start; /* Vasen reuna */ } .player.current { border: 2px solid #FFD700; /* Kulta reunus currentille */ } .player.out { background-color: #A52A2A; /* Punainen, ulos */ text-decoration: line-through; } .player.finished { background-color: #FFD700; /* Kultainen, valmis (sijoitus) */ font-weight: bold; color: #333; /* Tumma teksti keltaiselle pohjalle */ } .player-info { display: flex; justify-content: space-between; align-items: center; width: 100%; font-weight: bold; margin-bottom: 5px; /* Väliä historiaan */ } .nollat { font-weight: normal; /* Ei lihavointia nollille */ } .player-history { font-size: 0.9em; /* Hieman pienempi fontti historialle */ word-wrap: break-word; /* Rivittää pitkät listat */ } .remove-player { background-color: #FF0000; color: white; border: none; padding: 2px 8px; border-radius: 5px; cursor: pointer; font-size: 0.8em; } .remove-player:hover { background-color: #CC0000; } .player[draggable="true"] { cursor: move; } .score-input { display: flex; flex-direction: column; align-items: flex-start; margin-bottom: 20px; } .turn-row { display: flex; align-items: center; margin-bottom: 10px; } .buttons-row { display: flex; align-items: center; } select, input, button { padding: 10px; margin: 5px; border-radius: 5px; border: none; font-size: 1em; } button { background-color: #32CD32; /* Limevihreä */ color: white; cursor: pointer; } button:hover { background-color: #228B22; } #history { margin-top: 20px; background-color: rgba(255,255,255,0.2); padding: 10px; border-radius: 5px; } #add-player { display: flex; margin-bottom: 20px; } #player-name { flex-grow: 1; } /* Modal tyylit */ .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); padding-top: 60px; } .modal-content { background-color: #556B2F; /* Tummanvihreä */ margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 10px; color: #FFF; position: relative; } .close { color: #aaa; position: absolute; top: 10px; right: 20px; font-size: 28px; font-weight: bold; cursor: pointer; } .close:hover, .close:focus { color: white; text-decoration: none; } #rules-button { position: absolute; bottom: 20px; right: 20px; background-color: #32CD32; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; } #rules-button:hover { background-color: #228B22; } pre { background-color: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; font-size: 1em; white-space: pre-wrap; text-align: center; /* Keskitys diagrammille */ } </style>
Mölkkymatti
 <button onclick="addPlayer()">Lisää pelaaja</button>
<button onclick="resetGame()" style="margin-top:20px;">Aloita alusta</button> <button id="rules-button" onclick="openModal()">Pelin säännöt</button>
×
Mölkky-pelin säännöt
Järjestä numeroidut keilat tiiviiksi ryhmäksi 3,5 metrin päähän heittopaikasta seuraavassa järjestyksessä (rivit edestä taaksepäin, heittolinjaan nähden):
7 9 8 5 11 12 6 3 10 4 1 2
Pelaaja pyrkii kaatamaan numeroituja keiloja heittokeilalla.
Jos useita keiloja kaatuu, pelaajan pisteet ovat yhtä suuret kuin kaatuneiden keilojen määrä.
Yhden keilan kaataminen antaa sille merkityt pisteet.
Aseta kaatuneet keilat pystyyn sinne, minne ne putosivat, ja sitten on seuraavan pelaajan vuoro.
Virallisesti peli päättyy, kun ensimmäinen pelaaja saa tasan 50 pistettä, mutta Mölkkymattia voi käyttää myös pistelaskutavalla, jossa peli jatkuu, kunnes kaikki pelaajat paitsi viimeinen ovat saavuttaneet 50 pistettä. Jokainen, joka saa tasan 50, saa sijan (1., 2. jne.), ja viimeinen jäljellä oleva pelaaja saa viimeisen sijan automaattisesti.
Jos pelaaja ylittää 50 pistettä, hänen pistemääränsä vähenee 25 pisteeseen.
Jos pelaaja epäonnistuu kolmesti peräkkäin (ei kaada keiloja), hänen pelinsä päättyy.
<script> let players = []; let currentTurn = 0; let gameOver = false; let rankCounter = 1; let lastThrownTurn = -1; let isUndoAvailable = false; class Player { constructor(name) { this.name = name; this.score = 0; this.consecutiveMisses = 0; this.history = []; this.out = false; this.finished = false; this.rank = null; } addPoints(points) { if (this.out || this.finished || gameOver) return; this.history.push(points); if (points === 0) { this.consecutiveMisses++; if (this.consecutiveMisses >= 3) { this.out = true; alert(`${this.name} on ulkona! Kolme peräkkäistä nollaa.`); return; } } else { this.consecutiveMisses = 0; } let potential = this.score + points; if (potential === 50) { this.score = 50; this.finished = true; this.rank = rankCounter++; alert(`${this.name} sijoittuu ${this.rank}. sijalle!`); } else if (potential > 50) { this.score = 25; alert(`${this.name} ylitti 50! Pisteet pudotetaan 25:een.`); } else { this.score = potential; } } undoLast() { if (this.history.length > 0) { const lastPoints = this.history.pop(); this.score -= lastPoints; if (lastPoints === 0) { this.consecutiveMisses--; } else { this.consecutiveMisses = this.history.slice(-2).filter(p => p === 0).length; } if (this.finished) { this.finished = false; rankCounter--; this.rank = null; } this.out = false; gameOver = false; } } reset() { this.score = 0; this.consecutiveMisses = 0; this.history = []; this.out = false; this.finished = false; this.rank = null; } } function addPlayer() { const name = document.getElementById('player-name').value.trim(); if (name) { const exists = players.some(p => p.name.toLowerCase() === name.toLowerCase()); if (exists) { alert('Pelaaja samalla nimellä on jo lisätty!'); return; } players.push(new Player(name)); document.getElementById('player-name').value = ''; saveState(); renderPlayers(); if (players.length > 0) { document.getElementById('score-input').style.display = 'flex'; setCurrentTurn(0); } } } function removePlayer(index) { if (confirm(`Haluatko varmasti poistaa pelaajan ${players[index].name}?`)) { players.splice(index, 1); saveState(); if (players.length === 0) { document.getElementById('score-input').style.display = 'none'; } else if (currentTurn >= players.length) { currentTurn = 0; } renderPlayers(); setCurrentTurn(currentTurn); } } function canReorder() { return players.every(p => p.history.length === 0); } function renderPlayers() { const list = document.getElementById('player-list'); list.innerHTML = ''; const reorderable = canReorder(); players.forEach((p, i) => { const div = document.createElement('div'); div.className = 'player'; div.draggable = reorderable; div.dataset.index = i; if (i === currentTurn && !p.finished && !p.out) div.classList.add('current'); if (p.out) div.classList.add('out'); if (p.finished) div.classList.add('finished'); div.innerHTML = `
${p.name}: ${p.score} pistettä (nollat: ${p.consecutiveMisses})${p.rank ? ' - ' + p.rank + '. sija' : ''} <button class="remove-player" onclick="removePlayer(${i})">X</button>
Historia: ${p.history.join(', ')}
`; list.appendChild(div); }); if (reorderable) { addDragAndDropListeners(); } document.getElementById('undo-button').disabled = !isUndoAvailable; } function addDragAndDropListeners() { const list = document.getElementById('player-list'); list.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', e.target.dataset.index); e.target.style.opacity = '0.5'; }); list.addEventListener('dragend', (e) => { e.target.style.opacity = '1'; }); list.addEventListener('dragover', (e) => { e.preventDefault(); }); list.addEventListener('drop', (e) => { e.preventDefault(); const fromIndex = parseInt(e.dataTransfer.getData('text/plain')); const toIndex = Array.from(list.children).indexOf(e.target.closest('.player')); if (fromIndex !== toIndex) { const [movedPlayer] = players.splice(fromIndex, 1); players.splice(toIndex, 0, movedPlayer); saveState(); renderPlayers(); } }); } function addScore() { if (gameOver) return; const points = parseInt(document.getElementById('points').value); if (isNaN(points) || points < 0 || points > 12) { alert('Pisteet oltava 0-12!'); return; } isUndoAvailable = false; // Disable undo for previous, as new throw is added players[currentTurn].addPoints(points); lastThrownTurn = currentTurn; isUndoAvailable = true; renderPlayers(); checkEndGame(); saveState(); if (!gameOver) nextTurn(); } function nextTurn() { if (gameOver) return; let attempts = 0; do { currentTurn = (currentTurn + 1) % players.length; attempts++; if (attempts > players.length) { // Kaikki out tai finished gameOver = true; return; } } while (players[currentTurn].out || players[currentTurn].finished); setCurrentTurn(currentTurn); } function setCurrentTurn(turn) { currentTurn = turn; document.getElementById('current-player').innerHTML = `Heittovuorossa: ${players[currentTurn].name}`; renderPlayers(); } function checkEndGame() { const activePlayers = players.filter(p => !p.out && !p.finished).length; if (activePlayers <= 1) { gameOver = true; if (activePlayers === 1) { const lastPlayer = players.find(p => !p.out && !p.finished); lastPlayer.finished = true; lastPlayer.rank = rankCounter++; alert(`${lastPlayer.name} sijoittuu ${lastPlayer.rank}. sijalle (viimeisenä jäljellä olevana).`); renderPlayers(); } } } function undoLast() { if (!isUndoAvailable || lastThrownTurn === -1) return; if (confirm('Haluatko peruuttaa viimeisen heiton?')) { players[lastThrownTurn].undoLast(); currentTurn = lastThrownTurn; isUndoAvailable = false; saveState(); renderPlayers(); } } function resetGame() { players.forEach(p => p.reset()); currentTurn = 0; gameOver = false; rankCounter = 1; lastThrownTurn = -1; isUndoAvailable = false; document.getElementById('undo-button').disabled = true; document.getElementById('history').innerHTML = ''; saveState(); if (players.length > 0) { document.getElementById('score-input').style.display = 'flex'; setCurrentTurn(0); } else { document.getElementById('score-input').style.display = 'none'; } renderPlayers(); } function saveState() { const state = { players: players.map(p => ({ name: p.name, score: p.score, consecutiveMisses: p.consecutiveMisses, history: p.history, out: p.out, finished: p.finished, rank: p.rank })), currentTurn: currentTurn, gameOver: gameOver, rankCounter: rankCounter, lastThrownTurn: lastThrownTurn }; localStorage.setItem('molkymattiState', JSON.stringify(state)); } function loadState() { const savedState = localStorage.getItem('molkymattiState'); if (savedState) { const state = JSON.parse(savedState); players = state.players.map(data => { const p = new Player(data.name); p.score = data.score; p.consecutiveMisses = data.consecutiveMisses; p.history = data.history; p.out = data.out; p.finished = data.finished; p.rank = data.rank; return p; }); currentTurn = state.currentTurn; gameOver = state.gameOver; rankCounter = state.rankCounter; lastThrownTurn = state.lastThrownTurn || -1; if (players.length > 0) { document.getElementById('score-input').style.display = 'flex'; if (!gameOver) { nextTurn(); } setCurrentTurn(currentTurn); } isUndoAvailable = false; document.getElementById('undo-button').disabled = true; renderPlayers(); } } // Lataa tila sivun latauksen yhteydessä window.onload = loadState; // Modal-funktiot function openModal() { document.getElementById('rules-modal').style.display = 'block'; } function closeModal() { document.getElementById('rules-modal').style.display = 'none'; } // Sulje modal klikkaamalla ulkopuolelle window.onclick = function(event) { const modal = document.getElementById('rules-modal'); if (event.target == modal) { modal.style.display = 'none'; } } </script> ```